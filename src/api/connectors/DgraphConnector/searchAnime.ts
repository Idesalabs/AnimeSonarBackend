import { SearchAnimeInput, Anime, AnimeStatus, AnimeFormat } from '../../../generated/resolver-types';
import { DgraphClient } from 'dgraph-js';
import { AnimeDBInput } from './utils/parseAnimeToDbAnime';
import parseDbAnimeToAnime from './utils/parseDbAnimeToAnime';

const query = `
query searchAnime($anime:string, $limit:int){
    anime(func:alloftext(title, $anime),first: $limit){
      uid
      title
      coverImage
      bannerImage
      description
      minutesPerEpisode
      episodeCount
      isoAired
      
      has_tag@facets{
      uid
      name
      }

      has_format{
        uid
        name
      }
      
      has_status{
        uid
        status
      }
      has_genre@facets{
        uid
        name
      }
    }
    
  }
`

export default async (input: SearchAnimeInput, client: DgraphClient): Promise<Anime[]> => {
  try {
    const res = await client.newTxn().queryWithVars(query, { $anime: input.searchText, $limit: input.limit?.toString() ?? "10" })
    const { anime = [] } = res.getJson() as { anime: AnimeDBOutput[] }
    return anime.map(parseDbAnimeToAnime)
  } catch (error) {
    console.log(error)
    return []
  }
}


// Generated by https://quicktype.io

export interface AnimeDBOutput {
  uid: string;
  title: string;
  coverImage: string;
  bannerImage: string;
  description: string;
  minutesPerEpisode: number;
  episodeCount: number;
  isoAired: string;
  has_tag: Has[];
  "has_tag|score": { [key: string]: number };
  "has_tag|score_count": { [key: string]: number };
  has_status: HasStatus;
  has_genre: Has[];
  has_format: HasFormat
  "has_genre|score": { [key: string]: number };
  "has_genre|score_count": { [key: string]: number };
}

interface Has {
  uid: string;
  name: string;
}

interface HasFormat {
  uid: string
  name: AnimeFormat
}
interface HasStatus {
  uid: string;
  status: AnimeStatus;
}
